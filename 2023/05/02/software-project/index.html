<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>software project | 锦钊的博客</title><meta name="author" content="jinzhao"><meta name="copyright" content="jinzhao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="软件工程 黑盒测试习题：https:&#x2F;&#x2F;blog.csdn.net&#x2F;SKMIT&#x2F;article&#x2F;details&#x2F;125154722白盒测试习题:https:&#x2F;&#x2F;blog.csdn.net&#x2F;ly_6699&#x2F;article&#x2F;details&#x2F;88960070     1-1 软件工程的概念软件产品和物质产品有很大的区别，软件产品是一种 逻辑产品。 什么是软件？（软件系统的基本概念）软件（software">
<meta property="og:type" content="article">
<meta property="og:title" content="software project">
<meta property="og:url" content="http://123.249.26.15/2023/05/02/software-project/index.html">
<meta property="og:site_name" content="锦钊的博客">
<meta property="og:description" content="软件工程 黑盒测试习题：https:&#x2F;&#x2F;blog.csdn.net&#x2F;SKMIT&#x2F;article&#x2F;details&#x2F;125154722白盒测试习题:https:&#x2F;&#x2F;blog.csdn.net&#x2F;ly_6699&#x2F;article&#x2F;details&#x2F;88960070     1-1 软件工程的概念软件产品和物质产品有很大的区别，软件产品是一种 逻辑产品。 什么是软件？（软件系统的基本概念）软件（software">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-05-02T11:05:39.000Z">
<meta property="article:modified_time" content="2023-09-03T02:23:11.683Z">
<meta property="article:author" content="jinzhao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://123.249.26.15/2023/05/02/software-project/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'software project',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-03 10:23:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="锦钊的博客"><span class="site-name">锦钊的博客</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">software project</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-02T11:05:39.000Z" title="发表于 2023-05-02 19:05:39">2023-05-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-03T02:23:11.683Z" title="更新于 2023-09-03 10:23:11">2023-09-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="software project"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><hr>
<p>黑盒测试习题：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/SKMIT/article/details/125154722">https://blog.csdn.net/SKMIT/article/details/125154722</a><br>白盒测试习题:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/ly_6699/article/details/88960070">https://blog.csdn.net/ly_6699/article/details/88960070</a>   </p>
<hr>
<h2 id="1-1-软件工程的概念"><a href="#1-1-软件工程的概念" class="headerlink" title="1-1 软件工程的概念"></a>1-1 软件工程的概念</h2><p>软件产品和物质产品有很大的区别，软件产品是一种 <strong>逻辑</strong>产品。</p>
<p>什么是软件？（软件系统的基本概念）<br>软件（software）：一组对象或者项目所形成的一个“配置”，由<strong>程序，文档和数据</strong>等部分构成。<br>程序：可被计算机硬件理解并且执行的一组指令，提供预期的性能和功能<br>文档：与程序开发，维护，使用有关的图文资料<br>数据：程序能正常操作信息的数据结构</p>
<p>软件为什么需要不断地变化？  </p>
<ul>
<li>软件必须不断地变化来<strong>适应新的计算机环境或者新技术的发展</strong></li>
<li>软件必须通过不断的功能增强来<strong>实现新的业务需求</strong></li>
<li>软件必须通过扩展以与其他软件系统进行<strong>互操作</strong></li>
<li>软件必须不断重构，修复缺陷使得其<strong>生命周期的以延续</strong></li>
</ul>
<p><strong>软件不会磨损和老化，但是维护有困难</strong></p>
<p>课后习题？：<br><strong>软件不能被制造，软件有磨损老化，软件开发成本高，软件运行和开发必须依赖计算机环境。</strong></p>
<p>软件工程需要数学和管理学吗？<br>都需要。但是数学比重比较少，更偏重工程学和管理学。</p>
<p>软件的分类：</p>
<ol>
<li>系统软件：（system software）<strong>最靠近计算机硬件的一层软件</strong>—控制和协调计算机以及外部设备，支持应用软件开发与运行的软件。<br>eg： <strong>安卓，鸿蒙等操作系统</strong>，编译器和连接器，网络管理系统，数据库管理系统等。</li>
<li>支撑软件 ： （support software） 软件系统的中间层，支撑各种软件的开发，运行与维护的软件。<br>eg： <strong>网络构件，中间件</strong>以及软件运行平台，软件开发环境与工具，各种接口软件与工具组。</li>
<li>应用软件（application software）： 为满足特定应用领域，<strong>不同应用问题之需求</strong>的专用。<br>eg：<strong>web服务软件，服务形态的SaaS软件</strong>。</li>
</ol>
<p>软件危机的客观和主观原因是什么？（11+14）</p>
<ol>
<li><p>客观上：软件产品开发的<strong>复杂度和难度</strong>随软件规模呈指数增长</p>
<ul>
<li>随着软件规模的急速增长，传统的软件开发方法已经不可用了</li>
</ul>
</li>
<li><p>主观上：软件开发人员缺乏<strong>工程性的，系统性</strong>的方法论</p>
<ul>
<li>程序员具有编程能力，但是对软件开发这一个过程性较强的任务却缺少足够的<strong>工程化思维</strong></li>
<li>对软件开发的一些认识的误区：软件神话</li>
<li>没有将“<strong>软件产品研发</strong>”和<strong>程序编码</strong>区分清楚</li>
<li><strong>忽视需求分析，轻视软件维护</strong></li>
</ul>
</li>
</ol>
<p>软件的四大特征：  </p>
<ol>
<li><strong>复杂性</strong> ： 软件要解决的现实问题通常很复杂，数据，状态，逻辑关系的可能组合导致了软件本身的复杂性。<br>软件无法以<strong>制造</strong>的方式被生产，只能采用<strong>手工开发</strong>方式。这是一种人为，抽象化的智能活动（智力密集型），与人的水平密切相关。</li>
<li><strong>不可见性</strong>：尚未完成的软件是看不见的，无法像汽车一样充分呈现其结构。使得人们在沟通上面临着极大的困难，难以精确地刻画和度量。</li>
<li><strong>易变性</strong>：软件所应用的环境由人群，法规，硬件设备，应用领域等因素汇集而成，而这些因素都会快速变化。</li>
<li><strong>一致性</strong>：各子系统的接口必须协同一致。</li>
</ol>
<p><strong>软件危机</strong>： 计算机软件的开发和维护过程所遇到的一系列严重问题。<br>软件危机的表现（7）：  </p>
<ul>
<li><strong>对开发的成本和进度估计很不准确</strong>，甚至严重拖期和超出预算</li>
<li>无法满足<strong>用户需求</strong>，使客户很不满意</li>
<li>质量<strong>不可靠</strong>，经常失效</li>
<li>难以更改和<strong>调试</strong>增强</li>
<li>没有适当的<strong>文档</strong></li>
<li>软件<strong>成本比重</strong>上升</li>
<li>软件<strong>开发生产效率</strong>跟不上计算机应用迅速深入的趋势。</li>
</ul>
<p><strong>软件神话</strong>： 关于软件及其开发过程的一些说法被人盲目相信。</p>
<ul>
<li>影响到几乎所有的角色： 管理者，顾客，其他非技术性的角色，具体技术人员。</li>
<li>看起来是事实的合理描述（有时也确实包含真实的成分），符合直觉，经常被拿来做宣传。</li>
</ul>
<p>实际上误导了管理人员和技术人员<strong>对软件开发的态度</strong>，从而引发了严重的问题。<br>eg：<br>客户：  </p>
<ul>
<li><strong>有了对项目目标的大概了解，便足以开始编写程序</strong>，我们可以在之后的开发过程中逐步补充新的需求</li>
<li>如果我们将一个软件外包给一家软件公司，我们完全可以<strong>放手不管</strong>。</li>
</ul>
<p>软件公司管理者：  </p>
<ul>
<li><strong>我们已经有了一本写满软件开发标准和流程的“宝典”</strong>，它无所不包，囊括了我们可能遇到的任何问题</li>
<li>如果我们未能按时完成任务，<strong>我们可以通过增加程序员人数而赶上进度</strong></li>
<li><strong>只要我们使用了最先进的软件开发语言</strong>，开发工具和开发环境，我们的软件项目将会一帆风顺</li>
</ul>
<p>软件工程产生的根源？  </p>
<ol>
<li>由于计算机应用的不断发展，使得软件规模增大，数量增多，<strong>造成了软件成本增大，质量下降</strong>。  </li>
<li>同时个性化的软件开发方法<strong>使得软件维护困难</strong><br>以致于形成软件危机，软件神话也不存在，软件危机又亟待解决，所以形成了软件工程。<br><img src="/2023/05/02/software-project/2023-05-06-16-30-45.png"></li>
</ol>
<p>软件工程的概念？<br>软件工程师为了 <strong>经济</strong> 的获得能够在 <strong>实际机器上高效运行的可靠软件</strong> 而建立和使用的一系列 <strong>工程化原则</strong>  </p>
<p>软件工程的范围：</p>
<ol>
<li>软件开发过程（设计，开发，运行，维护）</li>
<li>软件开发中应该遵循的原则和管理技术</li>
<li>软件开发中所采用的技术和工具</li>
</ol>
<p>软件工程的目标：</p>
<ol>
<li>高质量</li>
<li>按时交付</li>
<li>控制成本</li>
<li>满足用户需求</li>
</ol>
<p>软件工程的分类：<br>结构化 ，面向对象，面向服务的软件开发方法。  </p>
<p>结构化方法：<br>软件&#x3D;程序+文档+数据  </p>
<p>面向对象的软件：<br>面向对象的软件&#x3D;对象+消息  </p>
<p>构件化方法，web services：<br>面向构件的软件&#x3D;构件+框架<br>面向服务的软件&#x3D;服务+消息+总线。</p>
<h2 id="1-2软件工程核心思想"><a href="#1-2软件工程核心思想" class="headerlink" title="1-2软件工程核心思想"></a>1-2软件工程核心思想</h2><p>软件系统开发的共同本质：从<strong>现实空间的需求</strong>到<strong>计算机空间的软件代码</strong>之间的<strong>映射与转换</strong>  </p>
<p>软件空间的俩个映射以及其作用：</p>
<ol>
<li>概念映射 ： 问题空间的概念与解空间的<strong>模型化</strong>概念之间的映射</li>
<li>业务逻辑映射：问题空间的<strong>处理逻辑</strong>与解空间处理逻辑之间的映射</li>
</ol>
<p>软件工程的本质：<strong>用严格的规范和管理手段来缩小偏差，通过牺牲时间来提高质量</strong></p>
<hr>
<p>软件所关注的对象：<br><strong>产品</strong>： 各个抽象层次的产出物<br><strong>过程</strong>： 在各个抽象层次之间进行映射与转换。<br>软件工程具有“<strong>产品与过程二相性</strong>”的特点，必须把两者结合起来去考虑，而不能忽略其中任何一方。</p>
<p>软件工程所关注的目标：<br><strong>功能性需求</strong>：软件所实现的<strong>功能达到它的设计规范和满足用户需求</strong>的程度。<br>比如说  完备性，正确性，健壮性，可靠性（4）<br>完备性：软件能够支持用户所需求的全部功能的能力<br>正确性： 软件按照需求正确执行任务的能力<br>健壮性： 在异常情况下，软件能够正常运行的能力。其中包括容错能力，恢复能力。 <strong>实际上，正确性描述的是需求范围之内的行为，而健壮性描述的是软件需求范围之外的行为</strong>。<br>可靠性： 在给定时间和条件下，软件能够维持其正常工作而不发生故障的能力。  </p>
<p><strong>非功能性需求</strong>：系统能够完成所期望的工作的<strong>性能和质量</strong><br>eg：  </p>
<ul>
<li>效率：软件实现其功能所需要的计算机资源大小，“时间-空间”</li>
<li>可用性：用户使用软件的可用程度</li>
<li>可维护性： 软件适应变化的能力</li>
<li>可移植性： 软件不经修改或者稍加修改就可以运行不同硬件环境的能力</li>
<li>清晰性：易于理解</li>
<li>安全性： 阻止非授权用户的使用</li>
<li>兼容性： 不同产品相互交换信息的能力</li>
<li>经济性： 开发成本，开发时间和对市场的适应能力</li>
<li>商业质量： 上市时间，成本受益，生命周期等。</li>
</ul>
<p><strong>“好”是最重要的，也就是说，质量是核心，以质量为中心，在“多，快，省”上面获得最佳平衡</strong></p>
<hr>
<p>软件开发中不同的角色？<br>软件开发过程中同样需要多个角色之间的紧密协作，才能高质量，高效率完成任务。</p>
<ol>
<li>顾客企业：（甲方）<ul>
<li>决策者</li>
<li>终端用户</li>
<li>系统管理员</li>
</ul>
</li>
<li>软件开发公司：<ul>
<li>决策者</li>
<li>软件销售和市场人员</li>
<li>咨询，需求分析师</li>
<li>软件架构师，软件设计师</li>
<li>开发人员：开发经理，项目经理，程序员</li>
<li>维护人员</li>
</ul>
</li>
</ol>
<hr>
<p><strong>软件工程的四个核心理论概念</strong>  </p>
<ol>
<li><p>分而治之： 将复杂的问题分解为若干可以独立解决的简单子问题，并且分别独立求解，以降低复杂性。<br><strong>核心问题</strong>：如何的分解策略可以使得软件更加容易理解，开发和维护。<br><strong>体现</strong>：软件体系结构的设计和模块设计。</p>
</li>
<li><p>复用：在一个新系统中，大部分内容是成熟的，只有一小部分内容是全新的，构造新的软件系统可以不必每次从零做起。<br><strong>主要思想</strong>：<br>  软件是由不同功能组件组成的有机体，各功能组件被设计成可完成同类工作的通用工具。组件建立起来后，软件开发变成将不同组件组织起来的简单问题。</p>
<p><strong>软件复用的三个基本核心问题</strong>：  </p>
<ol>
<li>必须有可以复用的对象</li>
<li>所复用的对象必须是有用的</li>
<li>复用者需要知道如何去使用被复用的对象</li>
</ol>
</li>
<li><p>折中：不同需求之间往往存在矛盾和冲突，需要通过折中来作出合理的取舍，<br><strong>核心问题</strong>：如何调和矛盾<br><strong>折中策略</strong>：通过协调各个质量因素使得整体质量最优<br><strong>重要原则</strong>：不能使某一方损失关键职能，更不能完全舍弃</p>
</li>
<li><p>演化： 软件系统在其生命周期中面临着各种变化。<br><strong>核心问题</strong>：在软件设计初期，就要充分考虑到未来可能的变化，并且采用恰当的<strong>设计策略</strong>使得软件<strong>具有适应变化的能力</strong>，即：<strong>可修改性，可维护性，可扩展性。</strong></p>
</li>
</ol>
<p><strong>软件的分而治之需要注意的问题</strong></p>
<ul>
<li>不可以“硬分硬治”。不像为了吃一个西瓜或者一只鸡，切成n块，每块塞进嘴里粉碎搅拌，最后给肠胃吸收。象征复杂问题的西瓜或者鸡也就此消失了。</li>
</ul>
<p>对于一个复杂的软件系统，运用 <strong>分而治之</strong> 的策略进行设计。<br>（软件的体系结构和模块化设计都是分而治之的具体表现）<br>熊掌烧鱼：使用一种基于<strong>折中策略</strong>的解决方案。</p>
<hr>
<p>什么是最佳实践？<br>最佳实践：是一个管理学概念，采用某种技术，方法，过程，活动或者机制可以使得生产或者管理实践的  <strong>结果达到最优，并且减少出错的可能性</strong></p>
<p><strong>IBM RUP最佳实践原则</strong>  ：</p>
<ol>
<li>迭代化开发</li>
<li>需求管理</li>
<li>使用基于构件的体系结构</li>
<li>可视化软件建模</li>
<li>持续质量验证</li>
<li>控制软件变更</li>
</ol>
<h2 id="2-1-软件过程模型"><a href="#2-1-软件过程模型" class="headerlink" title="2-1 软件过程模型"></a>2-1 软件过程模型</h2><p>软件过程定义以下内容：  </p>
<ol>
<li>人员与分工</li>
<li>所执行的活动</li>
<li>活动的细节与步骤</li>
</ol>
<p>软件过程的目的是什么？</p>
<ol>
<li>标准化（可模仿，成为可复用构件）</li>
<li>可预见性（降低风险）</li>
<li>提高开发效率</li>
<li>得到高质量产品</li>
<li>提升制定时间和预算计划的能力</li>
</ol>
<p>黑盒过程的缺点？</p>
<ol>
<li>要求开发之前需求被充分理解</li>
<li>与客户的交互只在开始和最后—类似于产品制造过程</li>
<li>而实际情况完全不是这样</li>
</ol>
<p>白盒过程的优点？</p>
<ol>
<li>通过改进可见性来减少风险</li>
<li>在开发过程中，通过不断地获得顾客的回馈</li>
<li>允许变更—类似于服务的过程</li>
</ol>
<p>什么是软件过程？软件过程包括哪些基本内容？  </p>
<ul>
<li>软件过程是指 <strong>软件生命周期</strong> 所涉及的一系列相关过程，由关于软件项目的 <strong>阶段，状态，方法，技术</strong>和开发，维护软件的 <strong>人员</strong> 以及 相关的 <strong>Artifacts（相关产品）（计划，文档，模型，编码，测试，手册）</strong>组成。</li>
<li>是软件整个生命周期从需求获取分析，设计实现，测试发布，维护的<strong>一个过程模型</strong></li>
<li><strong>工程开发</strong>，而且还涉及 <strong>工程支持和工程管理</strong></li>
</ul>
<p>内容是上面的</p>
<p><img src="/2023/05/02/software-project/2023-05-06-17-14-59.png"></p>
<hr>
<p>瀑布模型的优缺点？ （345）<br>瀑布模型也叫鲑鱼模型，因为它很难向前一阶段回溯。<br>上一阶段结束，下一阶段才开始。每个阶段均有里程碑和提交物。上一阶段的输出是下一阶段的输入。<br>优点：  </p>
<ol>
<li>追求效率。  <ul>
<li>它提供了一个模板，这个模板使得分析，设计，编码，测试和支持的方法可以在该模板下有一个共同的指导。</li>
<li>简单，易懂，易用，快速</li>
<li>为项目提供了按阶段划分的检查点，项目管理比较容易。每个阶段必须提供文档，而且要求每个阶段的产品必须进行正式严格的技术审查。</li>
</ul>
</li>
</ol>
<p>缺点：  </p>
<ol>
<li>过于理想化  <ul>
<li><strong>实际的项目大部分情况难以按照该模型的顺序进行，而且这种模型的迭代是间接的，很容易由微小的变化而造成大的混乱</strong></li>
<li>经常情况下，客户难以表达真正的需求，而这种却要求如此，这种模型是不欢迎二义性问题存在的</li>
<li>客户需要等到开发周期的晚期才能看到程序运行的测试版本，而这时发现大错误，可以引起恐慌。</li>
<li>采用这种线性模型，会经常在过程的开始和结束时碰到等待其他成员完成其依赖任务才能运行下去，有可能花在等待的时间比开发时间长，称为<strong>堵塞状态</strong></li>
</ul>
</li>
</ol>
<p>使用范围：</p>
<ol>
<li>软件的项目较小，各个模块间接口定义非常清晰</li>
<li>用户的需求非常清楚全面，而且在开发过程中没有或者很少进行改变</li>
<li>开发人员对软件的应用领域非常熟悉，使用的技术非常成熟</li>
<li>用户的使用环境非常稳定，外界不可控的因素较少</li>
<li>负责各个步骤的子团队分属不同结构或者不同地理位置，不可能频繁交流</li>
</ol>
<hr>
<p>增量方式的软件过程模型：<br>增量模型<br>RAD模型 </p>
<p>增量模型采用随着日程时间的进展而交错的线性序列。每个线性序列产生<strong>软件</strong>的一个可发布的<strong>增量</strong></p>
<p>增量模型（44）<br>本质： 以迭代的方式运行瀑布模型</p>
<ol>
<li><strong>第一个增量往往是核心产品：满足了基本的需求</strong>，但是缺少附加的特性</li>
<li>客户使用上一个增量的提交物并进行自我评价，制定下一个增量计划，说明要增加的特性和功能</li>
<li>重复上述过程，直到最终产品产生为止。</li>
</ol>
<p><strong>优点</strong>： </p>
<ol>
<li><strong>在时间要求较高的情况下交付产品。</strong> 在各个阶段并不是交付一个可运行的完整的产品，而是交付满足客户需求的一个子集的可运行产品，对用户起到“镇定剂”的作用。</li>
<li><strong>人员分配灵活</strong>。如果找不到足够开发人员，早期少量人员，若客户反应较好，投入更多人力</li>
<li><strong>逐步增加产品功能可以让用户有充裕的时间学习和适应新产品。</strong></li>
<li>因为较高优先权的模块首先被交付，<strong>因而最重要的功能接受了最多的测试，整体项目失败的风险度较低。</strong></li>
</ol>
<p>缺点：</p>
<ol>
<li>每个附加的增量并入现有的软件时，<strong>必须不破坏原来已经构建好的东西。</strong></li>
<li>同时，加入新增量时应简单，方便。<strong>该类软件的体系结构应当开放的</strong></li>
<li><strong>管理人员必须有足够的技术能力来协调好各增量之间的关系。</strong></li>
<li>但是，仍然无法处理需求发现变更的情况。</li>
</ol>
<hr>
<p>RAD模型：（24）  </p>
<ol>
<li><strong>侧重于短开发周期的增量过程模型。是瀑布模型的高速变体，通过基于构件的构建方法实现快速开发。</strong></li>
<li>多个团队并行进行开发，但是启动时间有先后，先启动团队的提交物将作为后启动团队的输入。</li>
</ol>
<p>缺点：</p>
<ol>
<li><strong>需要大量的人力资源</strong>来创建多个相对独立的RAD团队。</li>
<li><strong>如果没有短期内为急速完成整个系统做好装备</strong>，RAD项目将会失效。</li>
<li><strong>如果系统不能被合理的模块化</strong>，RAD将带来很多问题。</li>
<li><strong>技术风险很高的情况下，比如有新技术的时候，不能采用RAD</strong></li>
</ol>
<hr>
<p>背景：（面临的客观情况）  </p>
<ol>
<li><strong>软件系统随着时间推移而发生变化</strong>，而在开发过程中，需求经常发生变化，直接导致产品难以实现。</li>
<li><strong>严格的交付时间使得开发团队不可能圆满完成任务</strong>。但是必须交付功能有限的版本来应对竞争</li>
<li>很好理解产品与系统需求，<strong>但对其他扩展的细节没有很好定义</strong></li>
</ol>
<p>演化过程模型：<br>演化过程模型主要包括俩种形态：<br>快速原型法和螺旋模型法。<br><strong>本质：循环，反复，不断调整当前系统以适应需求变化</strong></p>
<p>原型区分： 抛弃式原型（不可执行） 和演化型原型（可执行，有较高的质量）</p>
<p>优点：<br>提高和改善了用户的参与程度，最大程度地响应用户需求的变化。<br>缺点：  </p>
<ol>
<li>为了尽快完成原型，开发者没有考虑整体软件的质量和长期的可维护性，系统结构可能较差。</li>
<li>可能混淆原型系统和最终系统， 原型系统在完全满足用户需求之后可能会被直接交付客户使用</li>
<li>额外的开销</li>
</ol>
<hr>
<p>螺旋式过程模型：<br>螺旋模型沿着螺线旋转，在四个象限内表达四个方面的活动：  </p>
<ol>
<li>制定计划： 确定软件目标，选定实施方案，弄清项目开发的限制。</li>
<li>风险分析： 分析所选方案，考虑如何识别和消除风险。</li>
<li>实施工程： 实施软件开发</li>
<li>客户评估：评价开发工作，提出修正建议。</li>
</ol>
<p>出发点：<strong>开发过程中及时识别和分析风险</strong>，并采取适当措施来消除或者减少风险带来的危害。  </p>
<p>优点：<strong>结合了原型的迭代性质与瀑布模型的系统性和可控性</strong>，是一种<strong>风险驱动</strong>的过程模型：</p>
<ol>
<li>采用循环的方式逐步加深系统定义和实现的深度，同时更好地理解和应对风险。</li>
<li>确定一系列里程碑，确保各方都得到可行的系统解决方案。</li>
<li>始终保持可操作性，直到软件生命周期结束。</li>
<li>由风险驱动，支持现有软件的复用。</li>
</ol>
<p>缺陷：</p>
<ol>
<li>适用于大规模软件项目，特别是<strong>内部项目</strong>，周期长，成本高</li>
<li>软件开发人员应该擅长寻找可能的风险，准确地分析风险，否则会带来更大的风险。</li>
</ol>
<hr>
<p>演化模型的缺点</p>
<p>演化过程模型的目的：<br><strong>需求的变更频繁，要求在非常短的期限内实现</strong>，以满足客户要求，及时投入市场。</p>
<h2 id="2-2-敏捷过程与方法"><a href="#2-2-敏捷过程与方法" class="headerlink" title="2-2 敏捷过程与方法"></a>2-2 敏捷过程与方法</h2><p>敏捷：多指动作或者言行迅速快捷。  </p>
<p>敏捷开发的本质：<strong>小步快跑，及时反馈，以快速的增量和迭代方式进行软件开发</strong>  </p>
<p>敏捷软件开发的核心：<strong>迭代开发</strong>  </p>
<p>敏捷开发的概念：<strong>敏捷方法是一种以人为核心，迭代，循序渐进的增量开发方法</strong>。 在软件项目的敏捷开发中，软件项目的初建被切分为<strong>多个子项目（迭代）</strong>，每个子项目的成果都<strong>经过测试</strong>，具备集成和可运行的特征。<br>也就是说，把一个大项目分为多个相互联系，但也可以独立运行的小项目，并分别完成，在此过程中软件一直处于<strong>可使用状态。</strong></p>
<hr>
<p>极限编程XP（一种最广泛应用的敏捷开发方法）的核心实践方法包括哪些内容：</p>
<ol>
<li>计划 ： 用户故事</li>
<li>设计 ： 测试驱动的开发</li>
<li>编程 ： <strong>结对编程</strong></li>
<li>测试 ： 持续集成</li>
</ol>
<p>极限编程和传统方法学的本质不同在于： <strong>它更强的可适应性，而不是可预测性</strong></p>
<p>极限编程XP的核心价值有哪些？<br><strong>沟通，简单，反馈，勇气，尊重</strong></p>
<hr>
<p>Scrum（一个敏捷开发框架）：  </p>
<ul>
<li>整个开发过程由<strong>若干个短的迭代周期</strong>组成，一个短的迭代周期称为一个Sprint（冲刺），每个Sprint的建议长度是2到4周。 </li>
<li>使用<strong>产品Backlog</strong>来管理需求，是让一个按照<strong>商业价值排序的需求列表</strong>，列表条目的<strong>体现形式通常为用户故事</strong>。</li>
<li>总是先开发对客户具有较高价值的需求</li>
<li>在Sprint中，Scrum团队 <strong>从产品Backlog中挑选最高优先级的需求</strong>进行开发。挑选的需求在Sprint计划会议上经过讨论，分析和估算得到相应的<strong>任务列表（Sprint backlog）</strong></li>
<li>在每个迭代结束时，Scrum 团队将提交<strong>潜在可交付的产品增量。</strong></li>
</ul>
<p>Scrum是一个轻量级的项目管理框架，它的核心在于迭代。</p>
<p>Scrum的三大特点：</p>
<ol>
<li>“可能性的”艺术</li>
<li>团队自组织，自管理</li>
<li>面对面沟通</li>
</ol>
<p>Scrum的四个重要阶段：</p>
<ol>
<li>找出完成产品需要做的事 Product Backlog</li>
<li>决定当前的冲刺需要解决的事情 Sprint Backlog</li>
<li>冲刺 Sprint</li>
<li>每日站会 DAILY SCRUM MEETING</li>
</ol>
<p>Scrum的三个工件：</p>
<ol>
<li>产品列表 Product Backlog ：  根据用户的价值进行优先级排序的高层需求</li>
<li>Sprint Backlog  ： 需要在冲刺中完成的任务清单（每个项都是一个用户故事）</li>
<li>产品增量 Increment  ：  最终交付个客户的内容</li>
</ol>
<p>Scrum的五个活动加一个合约：</p>
<ol>
<li>迭代：1-4周。团队用来实现迭代目标的时间区间。</li>
<li>迭代评审会议：团队展示完成的功能并收集反馈。所有人（包括客户）参加。</li>
<li>回顾会议：仅团队成员参与</li>
<li>迭代计划会议：进行迭代规划（发布计划会议，Sprint计划会议）</li>
<li>每日站立会议：站立进行，固定时间，固定地方</li>
</ol>
<p>合约：迭代合约</p>
<p>时间盒：<br>时间盒是指<strong>针对某个事件或者某个目标，给定一个固定的可用时间，这个时间不能缩小，也不能放大</strong><br>时间盒一般是一个比较短的时间，例如几小时或者几天。人们需要在这个给定的时间内尽全力去达成目标。</p>
<p>为什么使用时间盒？  </p>
<ol>
<li><strong>专注</strong>：心理学。</li>
<li><strong>提升互信</strong>：频繁达成小目标来让团队与外部干系人建立信心。</li>
<li><strong>降低复杂度</strong>：通过为期俩周的时间盒迭代，团队承受的是可管理的复杂度。做他们力所能及的工作。数据表明，低复杂度的步骤能够提高效率。</li>
<li><strong>尽早促成难度大的决策和权衡</strong>：<br>因为俩周就要向客户演示系统，所以迭代目标优先级不会含糊不清</li>
<li><strong>更好地过程控制</strong>：时间盒是一个以时间盒结束点的决定为标记的短期投资。它使得项目在走的过深而且不受控之前，让风险得到更多最小化的机会。</li>
<li><strong>尽早失败或者交付价值</strong>：<br>更早提供价值：意味着产出了有用的东西。尽早失败，意味着你能更尽早知道你能否到达目标，如果你不知道何去何从，可以回到起点，尝试其他途径。</li>
</ol>
<p>一句话归纳各类过程模型？</p>
<ul>
<li>瀑布模型：将全部需求以整体方式向前推进，无迭代 （基本模型）</li>
<li>增量模型： 将需求分为多份，串行推进，无迭代。（串行的瀑布）</li>
<li>RAD模型： 将需求分为多份，并行推进，无迭代。 （并行的瀑布）</li>
<li>原型模型： 迭代 （基本模型）</li>
<li>螺旋模型：按瀑布阶段划分，各阶段分别迭代（原型+风险分析）（原型加瀑布）</li>
<li>敏捷模型：将需求分成尽可能小的部分，以碎片为单位进行高速迭代（增量+迭代）</li>
</ul>
<p>敏捷开发过程中最重要的因素是人，有哪些具体要求？（8）  </p>
<ol>
<li>人 </li>
<li>能力</li>
<li>共同的兴趣</li>
<li>合作</li>
<li>决策能力</li>
<li>解决问题的能力</li>
<li>相互信任和尊重</li>
<li>自我组织</li>
</ol>
<p>Scrum 的基本过程包括哪些内容？</p>
<ol>
<li>找出完成产品需要做的事 Product Backlog</li>
<li>决定当前冲刺需要解决的事<br>Sprint Backlog</li>
<li>冲刺 Sprint</li>
<li>每次站会 Daily Scrum Meeting</li>
</ol>
<p>DevOps的概念？<br>是Development和Operation的组合词。是一种重视“<strong>软件开发人员（dev）”和“IT运维人员（OPS）</strong>”之间沟通合作的变化，运动或者惯例。透过<strong>自动化“软件交付”和“架构变更”</strong> 的流程,使得构建测试发布软件能够更加快捷频繁可靠。</p>
<p>DevOps 知识体系有哪些内容构成？</p>
<ul>
<li>敏捷管理</li>
<li>持续交付</li>
<li>IT服务管理</li>
<li>精益管理</li>
</ul>
<p><strong>DevOps是敏捷理念从开发领域到运维领域的延伸</strong></p>
<p><img src="/2023/05/02/software-project/2023-05-03-14-08-12.png"><br>如图：<br>生命周期过程：<br>DevOps <strong>它不仅仅体现在流程上打通了软件开发的整个生命周期，它还包括以下五个元素</strong>。</p>
<ol>
<li>首先是文化： DevOps与传统职能型团队不同，它的前提是建立一体化的全功能团队。打破开发与技术运营隔阂，形成DevOps的协作合作的文化氛围。</li>
<li>自动化。自动化一切可以自动化的，通过自动化的工具或者脚本实现软件工程从构建到运维过程的自动化流水线作业。</li>
<li>精益。以精益的方式小步快跑，持续改善</li>
<li>度量。建立有效的检测和度量手段获取快速反馈，推动改进，并且用于下一次迭代周期当中</li>
<li>分享。不同职能，不同产品之间经验分享能够促进DevOps的文化沉淀，促进产品迭代和更新。</li>
</ol>
<p><img src="/2023/05/02/software-project/2023-05-03-14-23-11.png"></p>
<p><img src="/2023/05/02/software-project/2023-05-03-14-23-45.png"></p>
<p>DevOps覆盖端到端的交付周期：<br>从<strong>交付全流程</strong>的覆盖范围看，也经历了<strong>敏捷开发，持续集成，持续发布，DevOps</strong>四个重要阶段。<br><img src="/2023/05/02/software-project/2023-05-06-18-24-29.png"></p>
<ol>
<li>敏捷让开发团队拥抱变化，快速迭代，覆盖了计划，编码，软件生成阶段。</li>
<li>持续集成让开发团队提交代码后，立即进行构建和单元测试，快速验证提交代码的正确性。  </li>
<li>持续发布则是在持续集成的基础上，将集成后的代码部署到更加贴近真实运行环境验证，让团队可以不断发布可用的软件版本。  </li>
<li>DevOps则是覆盖了全流程，加入了运维环节，用于促进开发，运维和质量保障部门之间的沟通，协作和整合。实现了工程效率最大化。</li>
</ol>
<p>看板：<br><strong>看板使得项目管理最大的可视化。更可以将研发的过程进行管理，记录下用户故事研发过程中的细节和历程</strong>。</p>
<p>看板工具的实质是：<br>后道工序在需要时，通过看板向前道工序发出信号。前道工序只有得到看板后，才按需生产。<strong>看板信号由下游向上游传递，拉动上游的生产活动，使得产品向下游流动</strong>。拉动的源头是最下游的客户价值，也就是客户订单或需求。</p>
<h2 id="2-3-软件项目管理"><a href="#2-3-软件项目管理" class="headerlink" title="2-3 软件项目管理"></a>2-3 软件项目管理</h2><hr>
<p>项目管理的关键因素（4P）？<br><strong>人员，过程，产品，项目</strong><br><img src="/2023/05/02/software-project/2023-05-03-14-25-52.png"></p>
<p>人员：（people）  </p>
<ul>
<li>高级管理者：负责制定业务问题  </li>
<li>项目管理者：计划激励组织控制软件开发人员  </li>
<li>开发人员  </li>
<li>客户</li>
<li>最终用户</li>
</ul>
<p>组织方式：  </p>
<ul>
<li>一窝蜂模式：没有明确的分工，存活时间一般不长。</li>
<li>主治医师模式： <strong>首席程序员处理主要模块的设计和编码</strong></li>
<li>社区模式： <strong>每个人参与自己感兴趣的项目，贡献力量。</strong> 人多力量大但是大家都来烤火不捡柴，或者火柴质量太差就不行。</li>
<li>交响乐团模式：<strong>人多，门类齐全，各司其职</strong>，各自有专门场地，严格遵循指挥。</li>
<li>爵士乐模式：<strong>主乐手先吹出主题，然后其余人员根据这个主题各自即兴发挥</strong></li>
<li>功能团队模式： <strong>具有不同能力的同事平等协作</strong></li>
<li>官僚模式： 成员之间不光技术方面有合作领导，同时还混进了 <strong>组织上领导和被领导的关系</strong>，跨组织合作变困难。</li>
</ul>
<hr>
<p>产品（product）：<br>首先确定软件的范围：</p>
<ul>
<li>功能和非功能的</li>
<li>软件的范围应该是确定的，在管理层和技术层都必须是无歧义的和可理解的。</li>
</ul>
<p>一旦确定了范围，需要对其进行分解-<strong>分而治之</strong><br>项目管理者通常使用“<strong>产品结构分解</strong>”（pbs）作为产品分解的工具：</p>
<p>基本原理：</p>
<ul>
<li>PBS： <strong>通过分层的树型结构来定义和组织项目范围内的所有产出物（产品）</strong>，自顶向下，逐级细分</li>
<li>产出物： 项目结束时候要提交的最终产品，在项目之初就可以准确预计</li>
</ul>
<hr>
<p>过程（process）：<br>相应的分解是“<strong>WBS</strong>”， <strong>工作结构分解</strong><br>WBS： <strong>通过分层的树型结构来定义和组织工作任务之间的分解关系</strong>，自顶向下，逐级细分</p>
<hr>
<p>项目（project）：<br>项目关注的四个方面：<br><strong>范围，时间，成本，质量</strong></p>
<p><strong>项目管理的主要任务：</strong>  </p>
<ul>
<li>项目可行性分析与估算</li>
<li>项目的进度安排</li>
<li>项目的风险管理</li>
<li>项目的质量管理</li>
<li>项目的跟踪与控制</li>
</ul>
<p>项目管理的基本原则：<br>W5HH</p>
<ol>
<li>Why 为什么开发这个系统</li>
<li>What 要做什么</li>
<li>When 什么时候做</li>
<li>Who 某功能由谁来做</li>
<li>Where 他们的组织结构位于何处</li>
<li>How 如何完成技术与管理工作</li>
<li>How much 各种资源需要多少</li>
</ol>
<p>项目管理通常采用哪种方式来描述任务的进度安排？<br><img src="/2023/05/02/software-project/2023-05-03-14-29-44.png"></p>
<p>软件项目质量管理定义：<br><strong>软件项目质量</strong>是软件项目<strong>符合明确叙述的功能和性能需求</strong>，以及<strong>所有专业开发软件都应具有的隐含特征</strong>的程度。</p>
<p>软件项目质量管理的核心要素有哪些？</p>
<ol>
<li>功能性</li>
<li>可信性（可靠性，可用性，安全性，保密性）</li>
<li>易使用性</li>
<li>可维护性</li>
<li>可移植性</li>
</ol>
<p><img src="/2023/05/02/software-project/2023-05-03-14-34-51.png"></p>
<hr>
<p>项目管理的基本概念<br>有效的 <strong>组织和管理</strong> 各类资源 ， 使得项目能够在预定的 <strong>范围，质量，时间，成本</strong>等约束条件下顺利交付。</p>
<h2 id="2-4-软件演化与配置管理"><a href="#2-4-软件演化与配置管理" class="headerlink" title="2-4 软件演化与配置管理"></a>2-4 软件演化与配置管理</h2><p>灰犀牛事件是指：太过于常见以致于人们习以为常的风险。比喻大概率且影响巨大的潜在危险。</p>
<p>黑天鹅事件：极其罕见，出乎人们意料的风险</p>
<p>为什么软件要演化？</p>
<ul>
<li>软件在使用过程中，新的需求不断出现</li>
<li>商业环境在不断变化</li>
<li>软件中的缺陷需要修复</li>
<li>计算机硬件和软件环境的升级需要更新现有的系统</li>
<li>软件的性能和可靠性需要进一步改善</li>
</ul>
<p>什么是软件演化？<br>是指在 <strong>软件生命周期内</strong> 进行 <strong>系统维护和系统更新</strong> 的动态行为， <strong>修正和改善</strong> 软件进入使用期后 <strong>暴露出的问题</strong> ， 以适<strong>应需求的不断变化</strong> </p>
<p>软件演化的Lehman定律：<strong>持续变化，复杂度增大</strong>。<br>持续变化： 现实世界的系统要么变得越来越没有价值，要么进行持续不断地变化来适应环境的变化。环境变化产生软件修改，软件修改又促进环境变化。<br>复杂度增大：  当系统逐渐发生变化时，其结构和功能将会变得越来越复杂，并且逐渐难以维护而失去控制，直到无法继续演化。</p>
<p>其中软件演化核心的问题是：如何使得软件系统适应外界的变化？</p>
<p><strong>软件演化过程</strong>是  <strong>软件演化和软件过程</strong> 的统一</p>
<p><strong>软件演化的策略</strong>：</p>
<ol>
<li>软件维护（为了修改软件缺陷或者增加新功能而对软件进行的变更。发生在局部，不会改变整个结构）</li>
<li>软件再工程（为了避免软件退化，对软件的一部分进行重新设计，编码和测试，提高软件的可维护性和可靠性）<br>前者比后者力度小</li>
</ol>
<p>什么是软件维护？<br>在软件产品发行和被投入使用之后对其的<strong>修改</strong>，以改正错误，改善性能或其他属性，从而使得产品<strong>适应新的环境或新的需求</strong></p>
<p>软件维护的类型：  </p>
<ol>
<li>纠错性维护：修改软件中的<strong>缺陷和不足</strong></li>
<li>适应性维护：修改软件使<strong>其适应不同的操作环境</strong>，包括硬件变化，操作系统变化或者其他支持软件变化等</li>
<li>完善性维护：<strong>增加或者修改系统的功能</strong>，使其适应不同业务的变化</li>
<li>预防性维护：为<strong>减少或避免以后可能需要的前三类维护</strong>而提前对软件进行的修改工作</li>
</ol>
<p>其中最多的维护是<strong>完善性维护</strong></p>
<p>软件维护的内容：</p>
<ul>
<li><strong>程序维护</strong>:根据使用的要求，对程序进行全部或者部分的修改。<strong>修改以后，必须书写修改设计报告</strong>。</li>
<li><strong>数据维护</strong>：对数据有较大的变动。如<strong>安装与转换新的数据库。或者某些数据文件或者数据库出现异常时的维护工作</strong>，比如文件的容量太大而出现溢出的情况。</li>
<li><strong>硬件维护</strong>：硬件人员应加强设备的保养和定期检修，并且做好检验记录和故障登记工作。</li>
</ul>
<p>软件的维护成本：极其昂贵</p>
<ul>
<li>业务应用系统：维护费用与开发成本大体相同</li>
<li>嵌入式实时系统：维护费用是开发成本的四倍以上</li>
</ul>
<p>软件维护的困难？？？？<br>软件维护中出现的大部分问题可以归咎于<strong>软件规划和开发方法的缺陷</strong>  </p>
<p><strong>遗留系统</strong>：已经运行了很长时间，对用户来说很重要，目前已经无法完全满足要求却不知道如何处理的软件系统。<br>特点：</p>
<ol>
<li>现有维护人员没有参与开发</li>
<li>不具备现有的开发规范</li>
<li>文档不完整，修改记录简略</li>
</ol>
<hr>
<p>软件配置管理（SCM）</p>
<p><strong>软件配置（software configuration）：由在软件工程过程中产生的所有信息项构成，它可以看成软件的具体形态（软件配置项）在某一时刻的瞬间映像</strong></p>
<p>协调软件开发从而使得混乱减到最小的技术称为 <strong>软件配置管理</strong>。其特点是：SCM贯穿整个软件的生命周期和软件工程过程。<br><img src="/2023/05/02/software-project/2023-05-07-20-38-55.png"></p>
<p>软件配置管理（SCM）：<br>SCM的<strong>目标</strong>：  </p>
<ul>
<li>标识变更</li>
<li>控制变更</li>
<li>确保变更的正确实现</li>
<li>向开发组织内各角色报告变更。<br>当变更发生时，能够提高适应变更的容易程度，并且能够减少所花费的工作量。</li>
</ul>
<p>扩展：<br><img src="/2023/05/02/software-project/2023-05-07-20-39-52.png"><br>配置项（SCI）：是软件全生命周期内<strong>受管理和控制的基本单位</strong>，大到整个系统，小到某个硬件设备或者软件模块。<br>基线：已经通过正式评审和批准的软件规格说明或者代码，可以作为进一步开发的基础，并且只有通过正式的变更才能修改它。因此可以看做软件开发过程中的 <strong>里程碑</strong>。<br>配置管理数据库：<br>用于保存与软件相关的所有配置项信息和配置项之间的关联的数据库。</p>
<p>持续集成的目标和核心措施？<br>目标：<strong>让产品能够快速迭代同时保持高质量</strong>（又快又好）<br>最终目标：从持续集成到持续交付<br>核心措施：代码在集成到主干之前，必修通过自动化测试，只要有一个测试用例失败，就不能集成。  </p>
<p>频繁发布，快速迭代快速交付，又随时可运行</p>
<p><img src="/2023/05/02/software-project/2023-05-03-14-42-22.png"></p>
<h2 id="2-5-Git与Github"><a href="#2-5-Git与Github" class="headerlink" title="2-5 Git与Github"></a>2-5 Git与Github</h2><h2 id="3-1-代码评审分析与优化"><a href="#3-1-代码评审分析与优化" class="headerlink" title="3-1 代码评审分析与优化"></a>3-1 代码评审分析与优化</h2><p>为什么要进行代码评审？<br>代码Review。<br>主要目的：是确保代码库一直保持<strong>健康</strong>的状态，代码评审的所有<strong>工具和过程</strong>都是为了这个目的而构建的。    代码评审会系统化地检查一遍源代码，并希望<strong>检查出开发初期未察觉的一些错误，从而提升代码质量</strong></p>
<p>代码评审的主要内容是什么？（8）  </p>
<ol>
<li><strong>设计</strong>（代码经过精心设计，适合我们的系统）</li>
<li><strong>功能性</strong>（代码行为是否和作者意图一致。对用户是否正常）</li>
<li><strong>复杂度</strong>（能更简单吗）</li>
<li><strong>测试</strong> （是不是通过了自动测试）</li>
<li><strong>命名</strong>（开发者选择易于理解的名称给变量，类，方法命名）</li>
<li><strong>评论</strong> （代码评论是否足够清晰有用。  </li>
<li><strong>风格</strong>（代码是否采用了标准的编写风格）</li>
<li><strong>文档</strong>（开发者是不是更新了相关文档）</li>
</ol>
<p>静态代码分析：在<strong>代码构建过程</strong>中帮助开发人员，快速有效的<strong>定位代码缺陷</strong>。</p>
<p>静态代码分析发现潜在bug所使用的主要技术有哪些？<br>主要技术有：<strong>缺陷模式匹配，类型推断，模型检查，数据流分析</strong><br>常用java静态代码分析工具：</p>
<ol>
<li>Checkstyle</li>
<li>FindBugs</li>
<li>PMD</li>
</ol>
<p><strong>代码复审的目的</strong>：</p>
<ol>
<li>找出代码的错误</li>
</ol>
<ul>
<li>编码错误，比如一些骗过编译器的错误</li>
<li>不符合项目组代码规范的地方</li>
</ul>
<ol start="2">
<li>发现算法错误。比如不够优化</li>
<li>发现潜在的错误和回归性错误。当前修改导致以前修复的缺陷重新出现</li>
</ol>
<hr>
<p>性能分析：以<strong>收集程序运行时信息</strong>为手段研究程序行为的分析方法。是<strong>动态程序分析</strong>的方法。</p>
<p>性能分析的目的是什么？  </p>
<ul>
<li>决定程序的哪个部分应该被优化，从而提高程序的速度或者内存使用效率。  </li>
<li>性能分析可以由程序的源代码或者可执行文件进行，一般会使用性能分析工具（profiler）进行。</li>
</ul>
<p>性能分析的方法：<br><img src="/2023/05/02/software-project/2023-05-07-20-09-21.png"><br><img src="/2023/05/02/software-project/2023-05-07-20-09-50.png"><br>一般的做法是：<br>先用抽样的方法找到效能瓶颈所在，然后用注入的方法进行详细分析。</p>
<hr>
<h2 id="3-2-软件测试"><a href="#3-2-软件测试" class="headerlink" title="3-2 软件测试"></a>3-2 软件测试</h2><p>产品测试？<br>是将<strong>产品原型</strong>或者<strong>产品成品</strong>提供给消费者，由消费者根据自己的想法对产品的属性进行评价，从中获得消费者的意见和建议。</p>
<p>为什么要进行测试？<br>简而言之，软件测试在软件企业中担当的是“<strong>质量管理</strong>”的角色，及时纠错，及时改正，确保。。。。。</p>
<p>软件测试？<br>使用<strong>人工或者自动的</strong>手段<strong>运行或者测定</strong>某个软件系统的过程。其目的在于检验它是否满足规定的需求  或者  弄清楚预期结果和实际结果之间的差别。（IEEE定义）</p>
<p><strong>软件测试的目的</strong>（3）：<br>帮助识别开发完成（中间或者最终的版本）的计算机软件（整体或者部分）的<strong>正确度，完全度和质量</strong><br>Glen Myers关于软件测试目的提出如下观点：  </p>
<ul>
<li>测试是<strong>为了发现错误而执行程序</strong>的过程</li>
<li>测试是为了 <strong>证明程序有错</strong>，而无法证明 <strong>程序正确</strong></li>
<li>一个好的测试用例在于能够发现 <strong>至今未发现</strong>的错误</li>
<li>一个成功的测试是 发现了<strong>至今未发现</strong>的错误的测试.</li>
</ul>
<p>用韦恩图来帮助理解测试：<br>软件测试基本上关心的是<strong>行为视图</strong>，而开发人员关心的是<strong>结构视图</strong></p>
<p>结构视图关注的是：  <strong>它是什么</strong><br>行为视图关注的是：  <strong>它做什么</strong></p>
<p>所以测试人员的难点之一，就是基本文档通常是由开发人员编写，并且是针对开发人员。<strong>因此这些文档强调的是结构信息，而不是行为信息。</strong></p>
<p>测试用例的特征：</p>
<ul>
<li>最有可能抓住错误的</li>
<li>不是重复的，多余的</li>
<li>一组相似测试用例中最有效的</li>
<li>既不是太简单也不是太复杂</li>
</ul>
<p>测试用例是为特定目的而设计的一组 <strong>测试输入，执行条件和预期结果</strong></p>
<p>测试用例的设计原则：</p>
<ul>
<li><p>测试用例的代表性：</p>
<p> 能够代表并且覆盖各种合理的和不合理的，合法的和非法的，边界的和越界的以及极限的<strong>输入数据，操作和环境设置</strong>等。</p>
</li>
<li><p>测试结果的可判定性：<br>测试执行的结果的正确性是可判定的，每一个测试用例都有相应的期望结果。</p>
</li>
<li><p>测试结果的可再现性：<br>对相同测试用例，执行结果相同。</p>
</li>
</ul>
<hr>
<p>白盒测试（又叫结构测试或者逻辑驱动测试）<br>把测试对象看做一个透明的盒子，它允许测试人员利用<strong>程序内部的逻辑结构和有关信息</strong>，设计或选择测试用例，对程序的所有<strong>逻辑路径</strong>进行测试。</p>
<p><img src="/2023/05/02/software-project/2023-05-07-19-19-35.png"><br><img src="/2023/05/02/software-project/2023-05-07-19-18-35.png"></p>
<p>黑盒测试：<br>通常在<strong>软件接口</strong>进行<br>原理：任何程序都可以看做是将<strong>输入定义域</strong>取值映射到<strong>输出值域</strong>的函数。<br>黑盒测试是以用户的角度，从<strong>输入数据与输出数据的对应关系</strong>出发，进行的测试。如果<strong>外部特性本身有问题或者规格说明的规定</strong>有误，用黑盒测试法无法发现。</p>
<p>测试用例的设计技术：<br><strong>等价类划分，边界值分析</strong>。</p>
<p>等价类划分是 <strong>黑盒测试</strong> 用例设计的一种设计方法。它将不能穷举的测试过程进行合理的<strong>分类</strong>，从而保证设计出来的测试用例具备<strong>完整性和代表性</strong></p>
<p>在等价类中，各个输入数据对于揭露程序中的错误是等效的，它们具有<strong>等价性</strong></p>
<p>等价类划分的关键步骤： <strong>确定等价类和选择测试用例</strong><br>基本原则：  </p>
<ol>
<li>每个可能的输入属于某一个等价类</li>
<li>任何输入都不会属于多个等价类</li>
<li>用等价类的某个成员作为输入，存在误差，那么用该类的其他成员输入，也能检测到同样的误差。</li>
<li>划分成数目尽可能少的不相交的集合。</li>
</ol>
<p>在设计测试用例的时候时候不仅要考虑 <strong>有效等价类</strong> 还要考虑 <strong>无效等价类</strong><br>不仅接受合理还要接受经受意外的考验，这样测试才能保证具有较高的可靠性。<br>有效等价类实现了规格说明中的规定的功能。<br>无效等价类是不合理或者无意义的数据。可以有多类。</p>
<p>原则：<br><img src="/2023/05/02/software-project/2023-05-06-21-02-02.png"><br><img src="/2023/05/02/software-project/2023-05-06-21-02-33.png"><br><img src="/2023/05/02/software-project/2023-05-06-21-02-16.png"><br><img src="/2023/05/02/software-project/2023-05-06-21-02-42.png"></p>
<p><img src="/2023/05/02/software-project/2023-05-06-21-04-56.png"><br><img src="/2023/05/02/software-project/2023-05-06-21-05-33.png"><br><img src="/2023/05/02/software-project/2023-05-06-21-05-42.png"></p>
<ol>
<li>输入的个数 》&#x3D;0</li>
<li>标识符的组成。。。 一一</li>
<li>标识符的字符个数  可能是俩个无效</li>
<li>数值  范围</li>
<li>开头字符</li>
</ol>
<p><img src="/2023/05/02/software-project/2023-05-07-18-53-07.png"><br><img src="/2023/05/02/software-project/2023-05-07-18-54-42.png"></p>
<p>俩种测试方法的比较（5）？  </p>
<ol>
<li>白盒测试只考虑<strong>测试软件产品</strong>，它不保证完整的需求规格是否被满足。</li>
<li>黑盒测试只考虑测试 <strong>需求规格</strong> ，它不保证实现的所有部分是否被检测到。</li>
<li>黑盒检测会发现 <strong>遗漏缺陷</strong>， 指出规格的哪些部分没有被完成。 而白盒测试会发现 <strong>代理方面缺陷</strong>， 指出哪些实现部分是 <strong>错误</strong>的。</li>
<li>白盒测试比黑盒测试成本要高得多。 它需要在测试 <strong>可被计划前</strong> 产生源代码， 并且在确定合适的 <strong>数据</strong> 和决定软件 <strong>是否正确</strong>方面要花费更多的工作量。</li>
<li>一个白盒测试的失败会导致一次修改。这需要所有黑盒测试被重复执行并且<strong>重新决定白盒测试路径</strong>。</li>
</ol>
<hr>
<h4 id="软件测试模型有哪些？以及各自优缺点？"><a href="#软件测试模型有哪些？以及各自优缺点？" class="headerlink" title="软件测试模型有哪些？以及各自优缺点？"></a>软件测试模型有哪些？以及各自优缺点？</h4><p>传统的瀑布模型</p>
<ol>
<li>项目计划–》需求分析–》软件设计–》程序开发–》软件测试–》集成维护</li>
<li>优点（3）：<ul>
<li>强调 <strong>需求，设计</strong>的作用</li>
<li>前一阶段只需关注后续阶段</li>
<li>为项目提供 <strong>按阶段划分的检查点，里程碑清晰</strong></li>
</ul>
</li>
<li>缺点（4）：<ul>
<li>线性研发过程难以适应 <strong>需求的频繁变化</strong></li>
<li>项目周期 <strong>后段才可看见成果</strong> ，用户要到末期才能看到开发结果，增加开发风险</li>
<li>强制的里程碑，适应能力较差。</li>
<li>文档工作量较大。测试在项目后期，文档的开发带来很大工作量。</li>
</ul>
</li>
</ol>
<hr>
<p>软件测试的V模型：<br>优点  ： 以“编码”为黄金分割线，将整个过程分为 <strong>开发和测试</strong>， 并且 开发和测试之间是 <strong>串行</strong> 的关系。</p>
<p>缺点： 基于瀑布模型，将测试放在整个开发的最后阶段，没有让测试尽早介入开发当中，没有在需求阶段就进入测试。</p>
<hr>
<p>软件W模型或者双V模型：<br>W模型是由俩个V模型组成，<strong>一个是开发阶段，一个是测试阶段。</strong> 在W模型中开发和测试是 <strong>并行</strong> 的关系。<br>优点：<br>测试和开发并行，让 <strong>测试尽早介入开发环节</strong>， 使得测试尽早发现问题，尽早解决。<br>缺点：<br>虽然开发与测试并行了，但是在<strong>整个开发阶段，仍然是串行的</strong>。上一阶段未完全完成就无法进入下一阶段，<strong>不支持敏捷模式的开发</strong>。</p>
<hr>
<p>软件 X模型：<br>描述的是针对 <strong>单独程序片段</strong> 相互分离的 <strong>编码和测试</strong>。 此后进行频繁的交接，再通过 <strong>集成</strong>， 最终合成可执行的程序。 对这些程序进行测试，已经通过的程序可以进行封板提交给用户，也可以作为更大集成的一部分。<br><strong>解决了交接和频繁集成周期的问题</strong></p>
<hr>
<p>软件H模型：  </p>
<ul>
<li>软件测试活动<strong>完全独立</strong>，贯穿于整个产品周期，与其他流程<strong>并发</strong>进行。  </li>
<li>H模型强调把测试分为 <strong>测试准备和测试执行</strong>俩个不同的阶段。某个测试点准备就绪时，就可以从测试准备阶段进行到测试执行阶段。 软件测试可以 <strong>尽早</strong> 地进行，并且可以根据被测物的不同而分层次进行。  </li>
<li>在H模型中，测试是一个<strong>完全独立的模型</strong>，所以可以和其他的流程<strong>交叉</strong>地进行，便于尽早执行测试。</li>
</ul>
<hr>
<p>软件测试的过程以及相关活动？<br><img src="/2023/05/02/software-project/2023-05-03-19-11-16.png"></p>
<ol>
<li>开发者测试：<ul>
<li>单元测试</li>
<li>集成测试</li>
<li>确认测试</li>
<li>系统测试</li>
<li>性能测试</li>
</ul>
</li>
<li>客户测试：<ul>
<li>验收测试</li>
<li>安装测试</li>
</ul>
</li>
<li>用户测试<ul>
<li>试用测试</li>
</ul>
</li>
</ol>
<p>对上面测试基本过程进行介绍？  </p>
<p>单元测试：<br>定义：单元测试是对 <strong>基本组成单元</strong>进行的测试，有时也称 <strong>组件测试</strong> 。 单元测试一般由编写该单元代码的开发人员执行，该人员负责设计和运行一系列的测试以确保该单元符合需求。</p>
<p>集成测试：<br>定义： 集成测试的对象是 <strong>模块间的接口</strong>。 其目的是找出在模块接口上和系统体系结构上的问题。</p>
<p>确认测试：<br>检查软件能否按合同要求进行工作，即是否满足<strong>软件需求说明书</strong>中的确认标准</p>
<p>系统测试：<br>是将已经集成好的软件系统作为一个元素，与 <strong>计算机硬件，外设，某些支持软件，数据，人员</strong>等元素结合在一起，在 <strong>实际运行环境</strong>下进行的一系列测试。</p>
<p>验收测试：<br>以 <strong>用户</strong>为主的测试。<br>α测试是由用户在开发环境下测试。<br>β测试是软件的多个用户在实际使用环境下进行测试</p>
<p>回归测试：<br>回归测试是验证对系统的变更没有影响以前的功能，并且保证当前功能的变更是正确的。  <strong>任何阶段</strong></p>
<h2 id="4-1-软件设计与架构概论"><a href="#4-1-软件设计与架构概论" class="headerlink" title="4-1 软件设计与架构概论"></a>4-1 软件设计与架构概论</h2><p>软件设计的定义？<br>是从 <strong>软件需求规格说明书</strong> 出发，根据 <strong>需求分析阶段</strong> 确定的功能， <strong>设计软件系统的整体结构，划分功能模块，确定每个模块的实现算法以及编写具体代码，形成软件的具体设计方案。</strong><br>or<br><strong>为问题域的外部可见行为的规约增添实际的计算机系统实现所需的细节，包括人机交互，任务管理，数据管理等细节</strong></p>
<p>在SE中的位置？<br><img src="/2023/05/02/software-project/2023-05-03-15-02-09.png"></p>
<p>良好的软件设计的三个特征：  </p>
<ul>
<li>目标：设计必须是实现所有包含在分析模型中的明确需求以及客户期望的所有隐含需求</li>
<li>形态：对开发，测试，维护人员来说，设计必须是可读的，可理解的，可操作的指南。</li>
<li>内容：设计必须要提供软件的全貌。</li>
</ul>
<p><strong>设计阶段是软件工程中形成质量的关键阶段</strong></p>
<p>软件设计的四方面内容：</p>
<ul>
<li>结构（架构）设计：选择适合于需求的软件架构风格。定义软件系统各主要成分之间的关系。</li>
<li>接口设计：<strong>用户界面，软件接口，硬件接口。与其他软硬件系统，与人之间的交互关系</strong></li>
<li>数据设计：确定软件涉及的文件系统的结构以及数据库的模式，子模式，进行数据完整性和安全性的设计。<br>有俩种数据结构：全局数据结构（公共），局部数据结构（算法内部使用）</li>
<li>过程设计： 确定软件各个组成部分内的算法以及各部分的内部数据组织。<br><img src="/2023/05/02/software-project/2023-05-03-15-05-05.png"></li>
</ul>
<p>微服务架构的概念：<br><strong>把一个大型的单个应用程序和服务，拆分成数个或者数十个的支持微服务</strong>。它可以扩展单个组件而不是整个应用程序堆栈，从而满足服务等级协议。</p>
<p>本质：<strong>用一些功能比较明确的，业务比较精炼的业务去解决更大更实际的问题。</strong></p>
<p>微服务架构的标准有哪些？（7）  </p>
<ol>
<li><strong>分布式服务</strong>组成的系统</li>
<li>按照<strong>业务</strong>，而不是技术来划分组织</li>
<li>做有<strong>生命的产品</strong>而不是仅仅针对项目</li>
<li><strong>强服务个体和弱通信</strong></li>
<li><strong>自动化运维</strong></li>
<li><strong>高度容错性</strong></li>
<li><strong>快速演化和迭代</strong></li>
</ol>
<p>软件设计的两大阶段：<br>从工程管理角度看，软件设计包括：</p>
<ul>
<li><strong>概要设计：将软件需求转化为数据结构和软件的系统结构</strong></li>
<li><strong>详细设计： 就是过程设计，通过对结构表示细化，得到详细的数据结构和算法</strong>。</li>
</ul>
<hr>
<p>架构的共性</p>
<ul>
<li>构件：一组基本的构成要素</li>
<li>连接件： 这些要素之间的连接关系</li>
<li>物理分布： 这些要素连接之后形成的拓扑结构</li>
<li>约束： 作用于这些要素或连接关系上的限制条件</li>
<li>性能： 质量</li>
</ul>
<p>软件架构的作用：  </p>
<ol>
<li>交流的手段</li>
<li>可传递，可复用的模型</li>
<li>早期决策的决定 ：使设计者在复杂，矛盾的需求面前作出正确的选择。</li>
</ol>
<hr>
<p>架构中的核心概念<br><img src="/2023/05/02/software-project/2023-05-03-15-10-50.png"><br>构件：是具有某种功能的<strong>可复用的软件结构单元</strong>，表示了系统中主要的计算元素和数据存储  </p>
<p>接口与功能：<br>构件作为一个封装的实体，只能通过其<strong>接口</strong>与外部环境交互，表示了构件与外部环境的<strong>交互点</strong>，<strong>内部具体实现则可以被隐藏起来</strong>。<br>而构件内部所实现的功能以<strong>功能</strong>的形式体现出来，并通过接口向外发布，进而产生与其他构件之间的关联。</p>
<p>连接：<strong>构件间建立和维护行为关联与信息传播的途径。</strong><br>连接需要两方面的支持：“机制”和“协议”。<br>具体来说：<br>连接的机制：<strong>连接发生和维持的机制</strong>，实现连接的<strong>物质基础</strong><br>连接的协议：连接正确有效的进行信息交换的规则</p>
<p>连接的分类：同步连接机制和异步连接机制<br><img src="/2023/05/02/software-project/2023-05-03-15-14-26.png"></p>
<p>连接件：<strong>表示构件之间的交互并实现构件之间的连接</strong><br>连接件也可以看做一类特殊的构件，区别在于：</p>
<ul>
<li>一般构件是软件功能设计和实现的承载体</li>
<li>连接件是负责完成构件间<strong>信息交换和行为联系</strong>的专用构件。</li>
</ul>
<p>软件架构的核心思想有哪些？<br>软件架构的四大思想：<br><img src="/2023/05/02/software-project/2023-05-02-21-04-47.png"></p>
<h2 id="4-2-SaaS与云端软件部署"><a href="#4-2-SaaS与云端软件部署" class="headerlink" title="4-2 SaaS与云端软件部署"></a>4-2 SaaS与云端软件部署</h2><p>C&#x2F;S 客户端&#x2F;服务器结构：</p>
<ul>
<li>用户的程序主要在客户端</li>
<li>服务器端主要提供数据管理，数据共享，数据以及系统维护和并发控制</li>
<li>客户端程序主要完成用户的具体的业务</li>
</ul>
<p><img src="/2023/05/02/software-project/2023-05-03-15-19-08.png"></p>
<p>三层C&#x2F;S体系结构：<br>在客户端和数据库服务器之间增加了一个中间层  </p>
<ul>
<li>第一层：用户界面–表示层</li>
<li>第二层：业务逻辑–功能层</li>
<li>第三层： 数据库 – 数据层<br>表示层向用户提供数据<br>功能层实施业务和数据规则<br>数据层定义数据访问标准<br><img src="/2023/05/02/software-project/2023-05-03-15-21-57.png"></li>
</ul>
<p>B&#x2F;S 浏览器&#x2F;服务器是三层C&#x2F;S风格的一种实现形式。<br><img src="/2023/05/02/software-project/2023-05-03-15-23-10.png"><br><img src="/2023/05/02/software-project/2023-05-07-21-02-17.png"></p>
<p>B&#x2F;S与三层C&#x2F;S结构的区别：</p>
<ul>
<li>C&#x2F;S表现层仍部署在客户端</li>
<li>B&#x2F;S客户端除了浏览器之前没有任何程序要部署。<br><img src="/2023/05/02/software-project/2023-05-03-15-24-45.png"></li>
</ul>
<p>C&#x2F;S + B&#x2F;S 混合模式遵循的原则是什么？</p>
<ol>
<li>内外有别的原则<ul>
<li>企业内部用户通过局域网直接访问数据库服务器<br>C&#x2F;S 交互性强，数据查询修改速率高</li>
<li>企业外部用户通过Internet 访问 Web服务器&#x2F;应用服务器<br>B&#x2F;S 用户不直接访问数据，数据安全</li>
</ul>
</li>
<li>查改有别原则：<ul>
<li>不管用户位于企业内外什么位置（局域网或者Internet），凡是需要对数据进行更新操作的，都需要使用C&#x2F;S结构</li>
<li>如果只是执行一般的查询与浏览操作，则使用B&#x2F;S结构<br><img src="/2023/05/02/software-project/2023-05-03-15-58-23.png"></li>
</ul>
</li>
</ol>
<p>M&#x2F;C结构：移动端云端结构（mobile&#x2F;cloud),可以看作是C&#x2F;S结构的扩展。客户端程序的体现形式： 各类APP或者小程序。</p>
<hr>
<p>SaaS（软件即服务）<br>SaaS软件的基本特征？与传统B&#x2F;S的本质区别是什么？  </p>
<ol>
<li>Saas： 本质上属于B&#x2F;S结构，对B&#x2F;S结构的扩展：<ul>
<li>通过<strong>web</strong>来管理和使用软件</li>
<li>软件被<strong>集中式</strong>地部署和管理，统一升级和维护</li>
<li><strong>单实例,多租户</strong></li>
</ul>
</li>
<li>本质区别：<strong>多租户共享Server和软件实例</strong></li>
</ol>
<p>SaaS软件具体被划分为哪几个层次？每个层次有什么作用？<br><img src="/2023/05/02/software-project/2023-05-03-15-37-54.png"></p>
<hr>
<p>SaaS 软件的基本架构模式是MVC，其中MVC分别有什么作用？<br>MVC是如何运行的？  </p>
<ol>
<li>模型（M，model）：用于管理应用系统的行为和数据，并响应为获得其他状态信息（通常来自视图）而发出的请求，还响应更改状态的指令（来自控制器）—对应传统B&#x2F;S中的业务逻辑和数据</li>
<li>视图（V,view）：用于管理数据的显示—对应传统B&#x2F;S中的用户界面</li>
<li>控制器（C,controller）：用于解释用户的鼠标和键盘输入，以通知模型和视图进行相应的更改。—在传统B&#x2F;S结构中新增的元素</li>
</ol>
<p><img src="/2023/05/02/software-project/2023-05-03-15-46-29.png"></p>
<p>Cloud能提供哪些服务？举例说明。<br><img src="/2023/05/02/software-project/2023-05-03-15-48-01.png"></p>
<h2 id="4-3-基本架构风格"><a href="#4-3-基本架构风格" class="headerlink" title="4-3 基本架构风格"></a>4-3 基本架构风格</h2><p>整体理解：<br><img src="/2023/05/02/software-project/2023-05-03-15-49-28.png"></p>
<p>什么是架构风格？<br>架构风格，也被称为架构模式。换句话说是架构方面的套路。也可以说是 <strong>前人在架构方面总结出来的，用来解决特定问题的方法</strong></p>
<p>层次结构：<br>早已成为一种复杂系统设计的普遍性原则，俩个方面的原因：  </p>
<ol>
<li>事物天生就是从简单，基础的层次开始的</li>
<li>众多软件，大到操作系统，中到网络系统，小到应用程序都是层次化构建的</li>
</ol>
<p><img src="/2023/05/02/software-project/2023-05-07-21-07-44.png"><br><strong>增量步骤序列</strong>  <strong>每一层用不同方法实现，软件复用</strong></p>
<p>软件架构风格划分为哪几个层次？<br><strong>三个层次：代码模式，设计模式，架构模式</strong><br>代码模式： 也可以说是编码时的套路。一些技巧，是最低层次的套路。只能影响某一种方法或者类中的一些细节。<br>设计模式： 解决了一般性的设计问题，影响一个模块内部，是中等层次的重用策略。<br>架构模式：最高层层次的重用策略，实现定义好一些子系统，层，指定他们的责任，并把它们组织在一起的法则和指南。</p>
<p>简要介绍事件系统的基本构成与实现策略？<br>与“调用返回”方式相对应，从同步调用变为了<strong>异步调用</strong><br>基本构成：<br><strong>事件源，事件管理器，事件处理器</strong><br><img src="/2023/05/02/software-project/2023-05-03-16-00-30.png"><br>其中功能：</p>
<ol>
<li>分离的交互：发布者并不会意识到事件订阅者的存在</li>
<li>多对多通信： 采用发布&#x2F;订阅消息传递，一个特定事件可以影响多个订阅者</li>
<li>基于事件的触发器：控制流由接受者决定（基于发布的事件）</li>
<li>异步： 通过事件消息传递支持异步操作。</li>
</ol>
<p>事件风格实现的策略</p>
<ol>
<li>选择<strong>广播式</strong>，有目的的广播，只发送给那些已经注册过的订阅者。适用于相对较小的应用系统。</li>
<li><strong>观察者模式（第三方）</strong>： 发布订阅模式。定义了对象间的一对多组合关系，以便于一个对象的状态发生变化时，所有依赖于它的对象都可以得到通知并且自动刷新。（放风，拍卖）适用于分布式的业务场景。</li>
</ol>
<h2 id="5-1-软件需求与需求获取"><a href="#5-1-软件需求与需求获取" class="headerlink" title="5-1 软件需求与需求获取"></a>5-1 软件需求与需求获取</h2><p><strong>软件需求</strong>：以一种清晰，简洁，一致且无二义性的方式，描述用户对目标软件系统在功能，行为，性能，设计约束等方面的期望，是在开发过程中对系统的约束。<br>需求通常表达 <strong>做什么</strong>  而不描述 <strong>怎么做</strong></p>
<p>好的需求应该具备的特征：</p>
<ol>
<li>完整性： 每一项需求都必须将所要实现的功能描述清楚</li>
<li>正确性： 每一项需求都必须准确地陈述其所要开发的功能</li>
<li>可行性： 必须是在已知系统和环境的限制范围内可以实施的</li>
<li>必要性：每一项需求必须把客户真正所需要的和最终系统所需遵从的标准记录下来</li>
<li>划分优先级。</li>
<li>可验证性。测试用例。</li>
</ol>
<p><img src="/2023/05/02/software-project/2023-05-06-20-26-49.png"><br>完整性。。可验证性。。</p>
<p>产生不合格需求的原因：</p>
<ol>
<li><strong>用户需求的不断增加</strong>。项目庞大超出计划和预算范围。<br>整体结构日益紊乱</li>
<li><strong>没有足够的用户参与</strong>，自以为明白用户需求</li>
<li><strong>模棱俩可的需求</strong>，不同读者产生了不同的理解。</li>
<li><strong>不必要的特性</strong>。客户要求看上很酷的要求，但不实用，浪费成本。或者开发人员画蛇添足。</li>
<li><strong>过于精简的说明</strong></li>
<li>不准确的计划。对需求分析缺乏理解导致过分乐观的估计。</li>
<li>忽略了用户分类。软件由不同的人使用，频繁程度，教育水平都有差异。</li>
</ol>
<p>软件需求有哪些作用？</p>
<ol>
<li>充分<strong>理解</strong>现实中的业务问题，并且作为软件设计的<strong>基础</strong></li>
<li>为软件项目的<strong>成本，时间，风险估计</strong>提供准确的依据。</li>
<li>减少开发工作量，避免将时间和资源 <strong>浪费</strong> 在设计和实现 <strong>错误的需求</strong> 上</li>
<li>通过提供需求文档和需求基线，来有效的 <strong>管理系统演化与变更</strong></li>
<li>作为 顾客与开发团队之间 <strong>正式合同</strong> 的一部分</li>
<li>为最终的 <strong>验收测试</strong> 提供 <strong>标准和依据</strong></li>
</ol>
<p>软件需求有哪些？不同层次的软件需求？<br><img src="/2023/05/02/software-project/2023-05-05-11-34-05.png"></p>
<p>业务需求：客户对于系统的 <strong>高层次目标要求</strong> ， 定义了项目的 <strong>远景和范畴</strong><br>用户需求：从用户角度描述 <strong>系统功能性需求与非功能性需求</strong>， 通常只涉及系统外部行为而不涉及内部特性。<br>eg： 业务需求：学校想要计算机管理学生选课。<br>用户需求： 教务管理员希望啥功能。学会希望啥功能。</p>
<p>功能需求，非功能需求（NFR检验起来非常困难，一般采用 <strong>可度量</strong> 的特性进行描述）<br>功能性需求：功能或者服务<br>非功能性需求：性能，质量<br><img src="/2023/05/02/software-project/2023-05-05-16-58-10.png"></p>
<p>约束条件：系统设计和实现时候，必须满足的 <strong>限制条件</strong>， 对其权衡非常困难，甚至是不可能的。</p>
<p>业务规则：<strong>是指对业务定义和约束的描述</strong>，是对<strong>某些功能的可执行性</strong>或 <strong>内部执行逻辑</strong>的一些限制条件。<br>如果。。。那么。。。</p>
<p>外部接口需求：描述系统与其所处的 <strong>外部环境如何进行交互</strong><br>用户接口需求，硬件接口需求，软件接口需求<br>“从某些设备读取信号。。”</p>
<p><img src="/2023/05/02/software-project/2023-05-05-11-48-46.png"></p>
<p>产生不合格需求的原因有哪些？  </p>
<ol>
<li>无用户参与</li>
<li>用户的需求不断增加</li>
<li>模棱俩可的需求</li>
<li>不必要的特性</li>
<li>过于精简的规格说明</li>
<li>忽略了用户分类</li>
<li>不准确的计划</li>
<li>。。。。</li>
</ol>
<p>简要介绍需求获取的基本步骤？  </p>
<ol>
<li>了解相关背景知识和领域&#x2F;行业的知识，确定产品所期望的<strong>用户类</strong>。</li>
<li>与客户企业或者组织的高层人员进行交流，了解实际用户<strong>任务和目标</strong>以及这些任务所支持的<strong>业务需求</strong>。</li>
<li>与客户企业或组织的底层人员进行交流。<strong>获取每个用户类的详细的用户需求</strong>。</li>
<li>整<strong>理需求纪要，发现新的问题</strong>，并且重复1-3步。</li>
<li>需求分类和组织，以区别<strong>功能需求，非功能需求，约束条件，业务规则，外部接口需求</strong>，解决方法和附加信息。</li>
<li>优先排序和冲突解决。</li>
<li>得到最终需求清单，并与客户做最终的签字确认。</li>
</ol>
<p><img src="/2023/05/02/software-project/2023-05-06-14-55-23.png"></p>
<hr>
<h2 id="5-2-用户故事与用例建模"><a href="#5-2-用户故事与用例建模" class="headerlink" title="5-2 用户故事与用例建模"></a>5-2 用户故事与用例建模</h2><p>用户故事：是从用户角度来描述用户渴望得到的功能  </p>
<p>说明：<br>在敏捷开发中，需求表述为一组“用户故事”。<br>在传统的OO分析和设计方法中，需求被表述为一组“用例”。<br>区别在于<strong>大小不同，形式不同</strong>。</p>
<p><strong>先讲User Story “用户故事”</strong>：<br><strong>是从用户角度来描述用户渴望得到的功能</strong>:<br>   描述方式：<br>  角色（谁使用这个功能），目标和活动（需要完成什么样的功能），商业价值（为什么要实现这个功能，这个功能能带来什么价值）</p>
<p>遵循3C原则（三个组成部分）：</p>
<ul>
<li>Card（卡片）简要的文本陈述</li>
<li>Conversation（会话）用户如何与系统交互</li>
<li>Confirmation （确认）如何验证和测试</li>
</ul>
<p>用户故事卡的正面：Conversaiton<br>格式：作为一个《角色》，我想要《完成活动》，以便于《实现价值》描述需求  </p>
<p>背面：Confirmation<br>书写完成用户故事的规则和完成标准，格式为： Given…When…Then.</p>
<p>好的用户故事具备哪些特征？<br>INVEST  </p>
<ol>
<li>Independent：尽可能独立</li>
<li>Negotiable：可讨论的。它不是一个合同，没有详细的规约，后续开发阶段可以不断协商和改进。</li>
<li>Valuable：对客户有价值，以用户可理解的语言进行书写。</li>
<li>Estimatable：工作量可估计</li>
<li>Small：小</li>
<li>Testable：可测试的，可验证的</li>
</ol>
<hr>
<p>用例（Use Case）：<strong>表示系统提供的服务或者可执行的某种行为</strong></p>
<p>面向对象软件开发方法中的用例的四大特征：</p>
<ol>
<li><strong>行为序列</strong>：一个用例由一组可产生某些特定结果的行为构成，<strong>这些行为是不可再分解的</strong>。</li>
<li><strong>系统执行</strong>：系统为外部角色提供服务</li>
<li><strong>可观测到的，有价值的结果</strong>：用例必须对用户产生价值</li>
<li><strong>特定的角色</strong>：某人，某设备，某外部系统或服务等，能触发某些行为。</li>
</ol>
<hr>
<p>用例方法的基本思想：<br>从用户角度来看，他们并不想了解系统的内部结构和设计，<strong>他们关心的是系统能够提供的服务，也就是被开发出来的系统是如何被使用的</strong></p>
<p>用例模型主要由以下元素构成：</p>
<ul>
<li><p>参与者：代表系统的<strong>使用者或者使用环境</strong></p>
</li>
<li><p>用例</p>
</li>
<li><p>通讯关联：用于<strong>表示参与者和用例之间的关系</strong>，它表示了参与者使用了系统中哪些服务（用例），系统所提供的服务（用例）是被哪些参与者使用的。<br>通讯关联<strong>不表示参与者和用例之间的信息流，并且信息流向是双向的，它与通讯关联箭头所指的方向没有关系</strong>。</p>
<p>用例方法的优点：</p>
<ol>
<li>用例模型容易构建，也容易阅读</li>
<li>完全站在用户的角度上，从系统外部来描述功能。</li>
<li>帮助系统的最终用户参与到需求分析过程中来，其需求更容易表达出来。</li>
</ol>
<p> UML活动图提供了一种可视化的流程图方式。对use case的事件流进行直观展示，便于读者理解。</p>
<p> <img src="/2023/05/02/software-project/2023-05-07-19-29-10.png"></p>
<hr>
</li>
</ul>
<p><img src="/2023/05/02/software-project/2023-05-07-19-05-56.png"></p>
<p>  大题<br>  简要阐述用例建模的基本过程？</p>
<ol>
<li><p>识别并描述参与者<br>  <img src="/2023/05/02/software-project/2023-05-03-16-37-25.png"><br>   <img src="/2023/05/02/software-project/2023-05-03-16-36-20.png"><br>   <img src="/2023/05/02/software-project/2023-05-03-16-36-38.png"></p>
</li>
<li><p>识别用例，并给出简要描述<br><img src="/2023/05/02/software-project/2023-05-03-16-37-55.png"><br><img src="/2023/05/02/software-project/2023-05-03-16-38-45.png"><br><img src="/2023/05/02/software-project/2023-05-03-16-38-55.png"></p>
</li>
<li><p>识别参与者与角色之间的通讯关联<br>   <img src="/2023/05/02/software-project/2023-05-03-16-39-19.png"></p>
</li>
<li><p>给出每一个用例的详细描述<br><img src="/2023/05/02/software-project/2023-05-03-16-41-25.png"></p>
</li>
<li><p>细化用例模型<br><img src="/2023/05/02/software-project/2023-05-03-16-41-48.png"></p>
</li>
</ol>
<p>  <img src="/2023/05/02/software-project/2023-05-03-16-43-00.png"><br>  <img src="/2023/05/02/software-project/2023-05-03-16-43-08.png"><br>  <img src="/2023/05/02/software-project/2023-05-03-16-43-16.png"></p>
<hr>
<p>  <img src="/2023/05/02/software-project/2023-05-03-16-51-06.png"><br>  <img src="/2023/05/02/software-project/2023-05-03-16-50-45.png"></p>
<h2 id="6-1-面向对象的基本概念"><a href="#6-1-面向对象的基本概念" class="headerlink" title="6-1 面向对象的基本概念"></a>6-1 面向对象的基本概念</h2><h2 id="6-4-面向对象的设计"><a href="#6-4-面向对象的设计" class="headerlink" title="6-4 面向对象的设计"></a>6-4 面向对象的设计</h2><h2 id="考试真题："><a href="#考试真题：" class="headerlink" title="考试真题："></a>考试真题：</h2><ol>
<li>分析模型一般使用<strong>需求分析评审</strong>方式进行验证</li>
<li>在分层的体系结构中，<strong>控制层</strong>实现与实体对象相关的业务逻辑。</li>
<li><strong>设计模式</strong>可以帮助人们简单方便地复用已经成功的设计或者体系结构。</li>
<li>为了使程序能够在不同的计算机上运行，程序应当具有 <strong>可移植性</strong></li>
<li>为了保证软件的质量，使其具有较好的可维护性，关键在于<strong>选择好的程序设计风格</strong></li>
<li><strong>功能测试</strong>是根据软件需求规格说明和测试需求列表，验证产品的功能实现是否符合需求规格。</li>
<li><strong>系统实施</strong>是将系统设计方案与软件系统转化为实际可运行系统的全过程</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://123.249.26.15">jinzhao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://123.249.26.15/2023/05/02/software-project/">http://123.249.26.15/2023/05/02/software-project/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://123.249.26.15" target="_blank">锦钊的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/10/principle/" title="principle"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">principle</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/28/My-New-Post/" title="My New Post"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">My New Post</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">jinzhao</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">软件工程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1-1 软件工程的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">1.2.</span> <span class="toc-text">1-2软件工程核心思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">2-1 软件过程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%95%8F%E6%8D%B7%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">2-2 敏捷过程与方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">2-3 软件项目管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%BD%AF%E4%BB%B6%E6%BC%94%E5%8C%96%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">2-4 软件演化与配置管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-Git%E4%B8%8EGithub"><span class="toc-number">1.7.</span> <span class="toc-text">2-5 Git与Github</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%BB%A3%E7%A0%81%E8%AF%84%E5%AE%A1%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">1.8.</span> <span class="toc-text">3-1 代码评审分析与优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">1.9.</span> <span class="toc-text">3-2 软件测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%90%84%E8%87%AA%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.9.0.1.</span> <span class="toc-text">软件测试模型有哪些？以及各自优缺点？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84%E6%A6%82%E8%AE%BA"><span class="toc-number">1.10.</span> <span class="toc-text">4-1 软件设计与架构概论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-SaaS%E4%B8%8E%E4%BA%91%E7%AB%AF%E8%BD%AF%E4%BB%B6%E9%83%A8%E7%BD%B2"><span class="toc-number">1.11.</span> <span class="toc-text">4-2 SaaS与云端软件部署</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.12.</span> <span class="toc-text">4-3 基本架构风格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E4%B8%8E%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96"><span class="toc-number">1.13.</span> <span class="toc-text">5-1 软件需求与需求获取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E4%B8%8E%E7%94%A8%E4%BE%8B%E5%BB%BA%E6%A8%A1"><span class="toc-number">1.14.</span> <span class="toc-text">5-2 用户故事与用例建模</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.15.</span> <span class="toc-text">6-1 面向对象的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.16.</span> <span class="toc-text">6-4 面向对象的设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E8%AF%95%E7%9C%9F%E9%A2%98%EF%BC%9A"><span class="toc-number">1.17.</span> <span class="toc-text">考试真题：</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/03/Path-planning-based-on-drawing-Qt/" title="Path planning based on drawing (Qt)">Path planning based on drawing (Qt)</a><time datetime="2023-09-02T17:40:05.000Z" title="发表于 2023-09-03 01:40:05">2023-09-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/03/hello-world/" title="Hello World">Hello World</a><time datetime="2023-09-02T17:31:30.858Z" title="发表于 2023-09-03 01:31:30">2023-09-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/03/compilation-principle/" title="compilation-principle">compilation-principle</a><time datetime="2023-09-02T17:31:30.856Z" title="发表于 2023-09-03 01:31:30">2023-09-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/10/principle/" title="principle">principle</a><time datetime="2023-05-10T13:20:48.000Z" title="发表于 2023-05-10 21:20:48">2023-05-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/02/software-project/" title="software project">software project</a><time datetime="2023-05-02T11:05:39.000Z" title="发表于 2023-05-02 19:05:39">2023-05-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By jinzhao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>